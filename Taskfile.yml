# TASK_X_REMOTE_TASKFILES=1 task remote:lint
# - cmd: steps that will be run sequentially.
# - deps: tasks that will be run in parallel.
---
version: "3"
vars:
  # Variables that have to be defined first as they are used in other variables.
  GOBIN:
    sh: |
      if [ -z "${GOBIN}" ]; then
        if [ -n "${GITHUB_ACTIONS}" ]; then
          echo /home/runner/go/bin
          exit 0
        fi
        echo "GOBIN has not been not set. Ensure that it has been set on the system."
        exit 1
      fi
      # Ensure that GOBIN is set in the context of this Taskfile.
      echo ${GOBIN}
  OS_TYPE_MAC: Darwin
  # Variables that are sorted alphabetically and are used in the tasks.
  BUILD_TAGS: '{{ .BUILD_TAGS | default "component,e2e,integration" }}'
  CODE_COVERAGE_TIMEOUT: '{{.CODE_COVERAGE_TIMEOUT | default "4m0s"}}'
  COVERPROFILE: profile.cov
  GCI: "{{.GOBIN}}/gci"
  GCI_SECTIONS: '{{.GCI_SECTIONS | default "--skip-generated -s standard -s default"}}'
  GCI_VERSION: 0.13.5
  GOFUMPT_VERSION: v0.7.0
  GOLANGCI_LINT_VERSION: 1.64.2
  GOLANGCI_LINT_RUN_TIMEOUT_MINUTES: "{{.GOLANGCI_LINT_RUN_TIMEOUT_MINUTES | default 3}}"
  GOLANG_PARALLEL_TESTS:
    sh: |
      if [ "$(uname -s)" = "{{.OS_TYPE_MAC}}" ]; then
        sysctl -n hw.ncpu
      else
        nproc
      fi
  GO_SWAGGER: "{{.GOBIN}}/swagger"
  GO_SWAGGER_VERSION: v0.31.0
  GOVULNCHECK_VERSION: v1.1.3
  GQLGENC_VERSION: v0.25.4
  HELM_VERSION: v3.16.2
  MCVS_TEXTTIDY_BIN: "{{.GOBIN}}/mcvs-texttidy"
  MCVS_TEXTTIDY_VERSION: 0.1.0
  MOCKERY_BIN: "{{.GOBIN}}/mockery"
  MOCKERY_VERSION: '{{.MOCKERY_VERSION | default "v2.52.2"}}'
  OPA_FMT: "{{.GOBIN}}/opa fmt ."
  OPA_VERSION: v0.70.0
  OS_COMMAND: uname
  OS_COMMAND_TYPE:
    sh: "{{.OS_COMMAND}} -s"
  OS_COMMAND_TYPE_ARCHITECTURE:
    sh: "{{.OS_COMMAND}} -m"
  REGAL: "{{.GOBIN}}/regal"
  REGAL_VERSION: 0.29.2
  SED_INSERT_ADDITION:
    sh: |
      if [ "{{.OS_COMMAND_TYPE}}" = "{{.OS_TYPE_MAC}}" ]; then
        echo "\"\""
      fi
  TEST_TIMEOUT: '{{.TEST_TIMEOUT | default "4m0s"}}'
  YQ_VERSION: v4.44.3
tasks:
  build-golang-download-modules:
    cmds:
      - |
        go mod tidy
    desc: download go modules
    silent: true
  coverage:
    cmds:
      - task: test
        vars:
          TEST_EXTRA_ARGS: >-
            -coverpkg=$(go list --tags={{.TEST_TAGS}} ./... | grep -v '{{.CODE_COVERAGE_FILE_EXCLUSIONS}}' | tr '\n' ',')
            -coverprofile={{.COVERPROFILE}} -timeout {{.CODE_COVERAGE_TIMEOUT}}
          TEST_TAGS: integration
      - |
        code_coverage_output=$(go tool cover -func {{.COVERPROFILE}})
        code_coverage_actual=$(echo "${code_coverage_output}" |\
          grep total: |\
          awk '{print $3}' |\
          sed 's/%//')

        echo "CODE_COVERAGE_FILE_EXCLUSIONS: {{.CODE_COVERAGE_FILE_EXCLUSIONS}}"
        echo "Code coverage overview:"
        echo "${code_coverage_output}"

        if (( $(echo "{{.CODE_COVERAGE_EXPECTED}} > ${code_coverage_actual}" | bc -l) )); then
          echo "The actual code coverage: '${code_coverage_actual}' is too low. Expected: '{{.CODE_COVERAGE_EXPECTED}}'. Resolve the issue by writing more unit and/or integration tests."
          exit 1
        elif (( $(echo "${code_coverage_actual} > {{.CODE_COVERAGE_EXPECTED}}" | bc -l) )); then
          echo "The actual code coverage: '${code_coverage_actual}' exceeds the expected coverage. Please adjust the threshold that is defined in the .github/workflows/golang.yml workflow from '{{.CODE_COVERAGE_EXPECTED}}' to '${code_coverage_actual}'."
          exit 1
        fi
    desc: check code coverage
    silent: true
  coverage-visual:
    cmds:
      - task: test
        vars:
          TEST_EXTRA_ARGS: >-
            -coverpkg=$(go list --tags={{.TEST_TAGS}} ./... | grep -v '{{.CODE_COVERAGE_FILE_EXCLUSIONS}}' | tr '\n' ',')
            -coverprofile={{.COVERPROFILE}} -timeout {{.CODE_COVERAGE_TIMEOUT}}
          TEST_TAGS: integration
      - |
        go tool cover \
          -func={{.COVERPROFILE}} > \
          functioncoverage.out
        go tool cover \
          -html={{.COVERPROFILE}} \
          -o coverage.html
        open ./coverage.html
    desc: show code coverage
    silent: true
  format:
    cmds:
      - task: gofumpt
      - task: gci-write
      - go mod tidy
    desc: format go files
  gofumpt-install:
    cmds:
      - task: keep-local-and-remote-versions-in-sync
      - |
        if ! gofumpt --version | grep -q "{{.GOFUMPT_VERSION}}"; then
          go install mvdan.cc/gofumpt@{{.GOFUMPT_VERSION}}
        fi
    silent: true
  gofumpt:
    cmds:
      - task: gofumpt-install
      - gofumpt -w .
    desc: format go files with gofumpt
    silent: true
  helm-install:
    cmds:
      - task: keep-local-and-remote-versions-in-sync
      - |
        if ! helm version | grep -q "{{.HELM_VERSION}}"; then
          curl \
            -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 |\
            bash -s -- --version {{.HELM_VERSION}}
        fi
    silent: true
  gci-install:
    cmds:
      - task: keep-local-and-remote-versions-in-sync
      - |
        if ! {{.GCI}} --version | grep -q "gci version {{.GCI_VERSION}}"; then
          go install github.com/daixiang0/gci@v{{.GCI_VERSION}}
        fi
    silent: true
  gci:
    cmds:
      - task: gci-install
      - |
        if {{.GCI}} list {{.GCI_SECTIONS}} . | grep "\.go$"; then
          echo "One or more golang files detected with: 'incorrect import order':"
          echo " * Observe: '{{.GCI}} diff .'"
          echo " * Resolve: '{{.GCI}} write .'"
          exit 1
        fi
    desc: check for incorrect import order with gci
    silent: true
  gci-write:
    cmds:
      - task: gci-install
      - "{{.GCI}} write {{.GCI_SECTIONS}} ."
    desc: fix incorrect import order with gci
    silent: true
  golang-log:
    cmds:
      - |
        echo "GOBIN: {{.GOBIN}}"
        echo "GOLANG_PARALLEL_TESTS: {{.GOLANG_PARALLEL_TESTS}}"
  golangci-lint-install:
    cmds:
      - task: keep-local-and-remote-versions-in-sync
      - |
        if ! golangci-lint --version | grep -q "has version {{.GOLANGCI_LINT_VERSION}}"; then
          curl \
            -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh |\
            sh -s -- -b $(go env GOPATH)/bin v{{.GOLANGCI_LINT_VERSION}}
        fi
    silent: true
  golangci-lint-run:
    cmds:
      - task: golang-log
      - |
        golangci-lint run \
          --build-tags {{.BUILD_TAGS}} \
          --concurrency {{.GOLANG_PARALLEL_TESTS}} \
          --out-format=colored-line-number \
          --timeout {{.GOLANGCI_LINT_RUN_TIMEOUT_MINUTES}}m \
          --verbose
    silent: true
  golangci-lint:
    cmds:
      - task: golangci-lint-install
      - task: golangci-lint-run
    desc: run golangci-lint
    silent: true
  golangci-lint-run-without-cache:
    cmds:
      - task: golangci-lint-install
      - golangci-lint cache clean
      - task: golangci-lint-run
    desc: run golangci-lint without cache
  go-swagger-install:
    cmds:
      - |
        if ! {{.GO_SWAGGER}} version | grep -q "{{.GO_SWAGGER_VERSION}}"; then
          go install github.com/go-swagger/go-swagger/cmd/swagger@{{.GO_SWAGGER_VERSION}}
        fi
    silent: true
  govulncheck-install:
    cmds:
      - |
        if ! govulncheck --version | grep -q {{.GOVULNCHECK_VERSION}}; then
          go install golang.org/x/vuln/cmd/govulncheck@{{.GOVULNCHECK_VERSION}}
        fi
    silent: true
  govulncheck:
    cmds:
      - task: govulncheck-install
      - |
        govulncheck -tags {{.BUILD_TAGS}} ./...
    desc: check for vulnerabilities with govulncheck
    silent: true
  gqlgenc-install:
    cmds:
      - task: keep-local-and-remote-versions-in-sync
      - |
        if ! gqlgenc version | grep -q {{.GQLGENC_VERSION}}; then
          go install github.com/Yamashou/gqlgenc@{{.GQLGENC_VERSION}}
        fi
  keep-local-task-up-to-date-with-version-defined-in-action:
    cmds:
      - task: yq-install
      - |
        expected_task_version=$(curl -s {{.REMOTE_URL}}/{{.REMOTE_URL_REPO}}/{{.REMOTE_URL_REF}}/action.yml | yq '.inputs.task-version.default')
        expected_task_major_version=$(echo "${expected_task_version}" | sed -E 's/^([0-9]+).*/\1/')
        current_task_version=$(task --version | sed -E 's/.*([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
        if [ -z "${expected_task_version}" ] || [ -z "${current_task_version}" ]; then
          echo "Failed to extract the expected (default) or current version or both for Task. Please check the default task-version input parameter in the .github/workflows/golang.yml."
          exit 1
        fi

        if [ "${expected_task_version}" != "${current_task_version}" ]; then
          if [ -n "${GITHUB_ACTIONS}" ]; then
            echo "The task binary: ${current_task_version} differs from the expected: ${expected_task_version}. Updating it..."
            go install github.com/go-task/task/v${expected_task_major_version}/cmd/task@v${expected_task_version}
            exit 0
          fi

          echo
          echo "###############################################################"
          echo "#"
          echo "# WARNING"
          echo "#"
          echo "###############################################################"
          echo "#"
          echo "# The version of the local task binary: ${current_task_version}"
          echo "# differs from the expected: ${expected_task_version}."
          echo "# Resolve the issue by updating the local task binary to"
          echo "# version: ${expected_task_version}."
          echo "# A remediation option is to run:"
          echo "# 'go install github.com/go-task/task/v${expected_task_major_version}/cmd/task@v${expected_task_version}',"
          echo "# but the choice of installation method depends on the"
          echo "# preferred way to install Task."
          echo "#"
          echo "###############################################################"
          echo
          sleep 3 # to ensure that user will see the message
        fi
    silent: true
  keep-mcvs-golang-action-version-local-taskfile-in-sync-with-github-workflow:
    cmds:
      - task: yq-install
      - |
        expected_mcvs_golang_action_version=$(yq '.jobs."mcvs-golang-action".steps[] | select(.uses | test("schubergphilis/mcvs-golang-action@.*")) | .uses' .github/workflows/golang.yml | sed -E 's/.*@(.*)/\1/')
        current_mcvs_golang_action_version=$(yq '.vars.REMOTE_URL_REF' Taskfile.yml)
        if [ -z "${expected_mcvs_golang_action_version}" ] || [ -z "${current_mcvs_golang_action_version}" ]; then
          echo "Failed to extract the expected and current version or both for the mcvs-golang-action. Please ensure that the mcvs-golang-action is defined in lower case in the .github/workflows/golang.yml file and the the REMOTE_URL_REF variable is present in the Taskfile.yml."
          exit 1
        fi

        if [ "${expected_mcvs_golang_action_version}" != "${current_mcvs_golang_action_version}" ]; then
          if [ -n "${GITHUB_ACTIONS}" ]; then
            echo "Expected mcvs-golang-action: ${expected_mcvs_golang_action_version} is different than current version in Taskfile: ${current_mcvs_golang_action_version}, but do not let the pipeline fail otherwise Dependabot cannot update the version of the action."
            exit 0
          fi
          
          echo
          echo "###############################################################"
          echo "#"
          echo "# WARNING"
          echo "#"
          echo "###############################################################"
          echo "#"
          echo "# Expected mcvs-golang-action: ${expected_mcvs_golang_action_version},"
          echo "# but current version in Taskfile: ${current_mcvs_golang_action_version}."
          echo "#"
          echo "# Resolve the issue by updating the REMOTE_URL_REF in the"
          echo "# Taskfile.yml variable to: ${expected_mcvs_golang_action_version}."
          echo "#"
          echo "###############################################################"
          echo
          sleep 3 # to ensure that user will see the message
        fi
    desc: |
      Ensure that the mcvs-golang-action version in Taskfile.yml matches the
      one in .github/workflows/golang.yml. Since Dependabot updates only the
      workflow file, the Taskfile must be updated manually. This check ensures
      that any version mismatch causes the pipeline to fail, prompting the user
      to update the Taskfile to keep the pipeline running successfully.
    silent: true
  keep-local-and-remote-versions-in-sync:
    cmds:
      - task: keep-local-task-up-to-date-with-version-defined-in-action
      - task: keep-mcvs-golang-action-version-local-taskfile-in-sync-with-github-workflow
  lint:
    cmds:
      - task: golangci-lint
    desc: run golangci-lint (alias for golangci-lint)
    silent: true
  lint-with-gci:
    deps:
      - task: gci
      - task: golangci-lint
    desc: run gci and golangci-lint
    silent: true
  mcvs-texttidy-install:
    cmds:
      - task: keep-local-and-remote-versions-in-sync
      - |
        if ! {{.MCVS_TEXTTIDY_BIN}} --version | grep -q {{.MCVS_TEXTTIDY_VERSION}}; then
          go install github.com/schubergphilis/mcvs-texttidy/cmd/mcvs-texttidy@{{.MCVS_TEXTTIDY_VERSION}}
        fi
    silent: true
  mcvs-texttidy-run:
    cmds:
      - "{{.MCVS_TEXTTIDY_BIN}}"
    silent: true
  mcvs-texttidy:
    cmds:
      - task: mcvs-texttidy-install
      - task: mcvs-texttidy-run
    desc: |
      Install and run mcvs-texttidy to check for forbidden words in projects.
    silent: true
  mock-generate:
    cmds:
      - |
        mockery_major_version=$(echo "{{.MOCKERY_VERSION}}" | cut -d '.' -f 1)
        if ! {{.MOCKERY_BIN}} --version | grep "{{.MOCKERY_VERSION}}"; then
          go install github.com/vektra/mockery/${mockery_major_version}@{{.MOCKERY_VERSION}}
        fi
        echo "{{.MOCK_GENERATE_DIR}} {{.MOCK_GENERATE_INTERFACE_NAME}}"
        {{.MOCKERY_BIN}} \
          --dir {{.MOCK_GENERATE_DIR}} \
          --name {{.MOCK_GENERATE_INTERFACE_NAME}} \
          --tags {{.BUILD_TAGS}}
    desc: generate mocks
    silent: true
  opa-fmt:
    cmds:
      - task: opa-install
      - "{{.OPA_FMT}}"
    desc: check formatting rego files using opa
    silent: true
  opa-fmt-write:
    cmds:
      - task: opa-install
      - "{{.OPA_FMT}} --write"
    desc: apply formatting rego files using opa
    silent: true
  opa-install:
    cmds:
      - |
        if ! opa version | grep -q {{.OPA_VERSION}}; then
          go install github.com/open-policy-agent/opa@{{.OPA_VERSION}}
        fi
    silent: true
  opa-run:
    cmds:
      - |
        opa_cmd="opa test . --ignore \"*.json\""

        for dir in $(find . -type f -name '*.rego' -exec dirname {} \; | sort -u); do
          echo "Running ${opa_cmd} in directory: $dir"
          (cd "$dir" && ${opa_cmd} -v --explain={{.QUERY_EXPLANATION}})

          opa_code_coverage_overview=$(cd "$dir" && ${opa_cmd} -c)
          echo "OPA code coverage overview:"
          echo "${opa_code_coverage_overview}"

          opa_code_coverage_actual=$(echo "${opa_code_coverage_overview}" | jq .coverage)
          echo "opa_code_coverage_actual: ${opa_code_coverage_actual}"

          int_number=$(echo "$opa_code_coverage_actual" | bc)
          echo "int_number: ${int_number}"

          echo "opa_code_coverage_actual: ${opa_code_coverage_actual}"
          opa_code_coverage_actual_significance_of_two=$(echo $opa_code_coverage_actual | bc -l | xargs printf "%.2f")
          echo "opa_code_coverage_actual_significance_of_two: ${opa_code_coverage_actual_significance_of_two}"

          if (( $(echo "{{.OPA_CODE_COVERAGE_EXPECTED}} > ${opa_code_coverage_actual_significance_of_two}" | bc -l) )); then
            echo "The actual OPA code coverage: '${opa_code_coverage_actual_significance_of_two}' is too low. Expected: '{{.OPA_CODE_COVERAGE_EXPECTED}}'. Resolve the issue by writing more OPA unit tests."
            exit 1
          elif (( $(echo "${opa_code_coverage_actual_significance_of_two} > {{.OPA_CODE_COVERAGE_EXPECTED}}" | bc -l) )); then
            echo "The actual OPA code coverage: '${opa_code_coverage_actual_significance_of_two}' exceeds the expected coverage. Please adjust the threshold that is defined in the applicable GitHub workflow from '{{.OPA_CODE_COVERAGE_EXPECTED}}' to '${opa_code_coverage_actual_significance_of_two}'."
            exit 1
          fi
        done
    silent: true
    vars:
      QUERY_EXPLANATION: '{{.QUERY_EXPLANATION | default "fails"}}'
  opa:
    cmds:
      - task: opa-install
      - task: opa-run
    desc: |
      Install and run OPA. Issue: 'task remote:opa QUERY_EXPLANATION=full' to
      follow the complete policy evaluation.
    silent: true
  regal-install:
    cmds:
      - task: keep-local-and-remote-versions-in-sync
      - |
        if ! regal version | grep -q {{.REGAL_VERSION}}; then
          # regal version installed using `go install` does not include
          # version, see: https://github.com/StyraInc/regal/issues/1275
          curl -L -o {{.REGAL}} https://github.com/StyraInc/regal/releases/download/v{{.REGAL_VERSION}}/regal_{{.OS_COMMAND_TYPE}}_{{.OS_COMMAND_TYPE_ARCHITECTURE}}
          chmod +x {{.REGAL}}
        fi
    silent: true
  regal-run:
    cmds:
      - |
        if ! regal lint .; then
          echo "regal linting failed. Run: 'task remote:opa-fmt-write' to fix the issue"
          exit 1
        fi
    silent: true
  regal:
    cmds:
      - task: regal-install
      - task: regal-run
    desc: run regal
    silent: true
  test:
    cmds:
      - task: golang-log
      - |
        go test \
          -p {{.GOLANG_PARALLEL_TESTS}} \
          -race \
          -short \
          --tags={{.TEST_TAGS}} \
          ./... \
          {{.TEST_EXTRA_ARGS}} \
          -timeout {{.TEST_TIMEOUT}}
    desc: run unit tests
    silent: true
  test-cicd:
    cmds:
      - task: test
        vars:
          TEST_EXTRA_ARGS: >-
            -v
    desc: test within CICD should contain verbose logging to facilitate debugging
    silent: true
  test-component:
    cmds:
      - task: test
        vars:
          TEST_TAGS: component
    desc: run component tests
    silent: true
  test-component-cicd:
    cmds:
      - task: test-cicd
        vars:
          TEST_TAGS: component
    desc: run component tests in CICD
    silent: true
  test-e2e:
    cmds:
      - task: test
        vars:
          TEST_TAGS: e2e
    desc: run end-to-end tests
    silent: true
  test-e2e-cicd:
    cmds:
      - task: test-cicd
        vars:
          TEST_TAGS: e2e
    desc: run end-to-end tests in CICD
    silent: true
  test-integration:
    cmds:
      - task: test
        vars:
          TEST_TAGS: integration
    desc: run integration tests
    silent: true
  test-integration-cicd:
    cmds:
      - task: test-cicd
        vars:
          TEST_TAGS: integration
    desc: run integration tests in CICD
    silent: true
  yq-install:
    cmds:
      # Enabling the following task as a dependency will create an infinite
      # loop, as the yq-install unit is already a dependency within the called
      # unit.
      # - task: keep-local-and-remote-versions-in-sync
      - |
        yq_major_version=$(echo "{{.YQ_VERSION}}" | cut -d '.' -f 1)
        if ! yq --version | grep -q "version {{.YQ_VERSION}}"; then
          go install \
            github.com/mikefarah/yq/${yq_major_version}@{{.YQ_VERSION}}
        fi
    silent: true
